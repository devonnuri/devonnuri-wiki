---
title: 2025년 2월 4주차 TIL
---

# 250225

## BOJ 11000 : 강의실 배정 (Gold 5)

- $S_i$와 $T_i$를 한꺼번에 모은 뒤에 시간순으로 정렬하고 스택에 $S_i$를 넣고 $T_i$일때 pop하는 것을 반복한다.
- 이때 스택의 최대 크기가 강의실의 개수가 된다.
- 이렇게 구현하면 $T_i\leq S_j$일 경우가 눈에 띈다. 이 경우 스택의 최대 크기를 pop할 때 세되, $S_j$와 $T_i$의 값이 같을 경우 세지 않으면 된다.
  - 시간이 같을 때 $S$가 먼저 등장하고 $T$가 나중에 등장해야 스택을 유지할 수 있는데 우연히도 `S`가 `T`보다 앞서있다. 오예!

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  int N; cin >> N;
  vector<pair<int, char>> v; v.reserve(2*N);

  for (int i=0;i<N;i++) {
    int s, t; cin >> s >> t;
    v.emplace_back(s, 'S');
    v.emplace_back(t, 'T');
  }

  sort(v.begin(), v.end()); // 'S' < 'T'

  stack<int> s;
  int mm = -1;
  for (int i=0;i<2*N;i++) {
    auto [pos, st] = v[i];
    if (st == 'S') {
      s.push(pos);
    } else {
      if (s.top() != pos) {
        mm = max(mm, (int) s.size());
      }
      s.pop();
    }
  }

  cout << mm;

  return 0;
}
```

# 250226

## BOJ 1107 : 리모컨 (Gold 5)

- 남은 버튼으로 reachable한 채널 번호를 bitset에 저장하고 $N$으로부터 왼쪽 오른쪽을 넓혀가면서 검사해서 (숫자자릿수) + (+- 개수)로 답을 내면 된다.
- 시작 채널인 100번에서 +-하는게 효율적이면 그걸 따른다.
- 밑의 코드의 `d`가 같을 때 자릿수가 차이날 수 있기에 왼쪽이 우선이라는 점을 고려하지 못했다.

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef vector<int> vi;

bitset<1000001> dp;
bool digit[10];
void dfs(int i) {
  for (int j=0;j<=9;j++) {
    if (!digit[j]) continue;

    if (i*10+j <= 1000000) {
      dp[i*10+j] = true;
      if (i > 0 || j > 0) dfs(i*10+j);
    }
  }
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  int N, M; cin >> N >> M;

  memset(digit, true, 10);
  for (int i=0;i<M;i++) {
    int x; cin >> x;
    digit[x] = false;
  }

  dfs(0);

  int num = -1, d;
  for (d=0;d<=500000;d++) {
    if (N-d>=0 && dp[N-d]) { // smaller one first
      num = N-d;
      break;
    }
    if (N+d<=1000000 && dp[N+d]) {
      num = N+d;
      break;
    }
  }

  if (num == -1) { // no num button
    cout << abs(N-100);
  } else {
    cout << min((int) log10(max(num, 1)) + d + 1, abs(N-100));
  }

  return 0;
}
```

## BOJ 1197 : 최소 스패닝 트리 (Gold 4)

- MST를 구하는 문제다. Prim's Algorithm으로 구현했다.

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef pair<int, int> pii;

const int INF = numeric_limits<int>::max();

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  int V, E; cin >> V >> E;
  vector<vector<pii>> G(V+1);
  vector<int> key(V+1, INF);
  vector<bool> visited(V+1, false);

  for (int i=0;i<E;i++) {
    int a, b, w; cin >> a >> b >> w;
    G[a].emplace_back(w, b);
    G[b].emplace_back(w, a);
  }

  priority_queue<pii, vector<pii>, greater<>> pq;
  pq.emplace(0, 1);
  key[1] = 0;
  while (!pq.empty()) {
    int u = pq.top().second; pq.pop();
    visited[u] = true;

    for (auto [w, v] : G[u]) {
      if (!visited[v] && w < key[v]) {
        key[v] = w;
        pq.emplace(w, v);
      }
    }
  }

  cout << accumulate(key.begin()+1, key.end(), 0);

  return 0;
}
```

# 250227

## BOJ 33466 : 피타고라스 정리의 증명 (Gold 5)

- $2(a^2 + b^2) = kab$에서 $k$가 양의 정수가 되도록 하는 순서쌍 $(a, b)$ ($a,b\leq N$)의 개수를 구하는 문제이다.
- 식을 정리하면,

  $$
  \begin{aligned}
  2a^2-kab+2b^2 =0 \\
  2\left(\frac{a}{b}\right)^2 - k\left(\frac{a}{b}\right) + 2 = 0 \\
  \frac{a}{b}=\frac{k\pm\sqrt{k^2-16}}{4}
  \end{aligned}
  $$

- $\frac{a}{b}$가 유리수이므로, $k^2-16$은 완전제곱수이다.
- $l^2=k^2-16$이라고 하고, 일반성을 잃지 않고 $l$은 음이 아닌 정수라고 하자.
- $l$의 범위는 $0\leq l\leq 7$이다.
  - 수열 $s_n=n^2$ ($n=0,1,\cdots$)과 이 수열의 차이 $d_n=s_{n}-s_{n-1}$ ($n=1,2,\cdots$)을 생각하자.
  - $d_n = 2n-1$인데, $s_k$와 $s_l$의 차이인 16은 $d_8=15$와 $d_9=17$의 사이에 있다.
  - $i\geq 9$ 이상의 $d_i$을 $s_l$에 더해서 인접한 $s_k$를 만들 수 없다.
  - 모든 양의 정수 $n$에 대해 $d_n>0$이므로 $s_k$는 $s_l$와 인접하지 않더라도 만들어질 수 없다.
- 이제 가능한 $l$에 대해 $l^2+16$이 완전제곱수가 되는지 확인해주면 된다.
  <table
      style={{
        borderCollapse: "collapse",
        textAlign: "center",
      }}
  >
    <thead>
      <tr style={{ backgroundColor: "#f2f2f2" }}>
        <th style={{ border: "1px solid #ddd", padding: "5px" }}>$l$</th>
        <th style={{ border: "1px solid #ddd", padding: "5px" }}>0</th>
        <th style={{ border: "1px solid #ddd", padding: "5px" }}>1</th>
        <th style={{ border: "1px solid #ddd", padding: "5px" }}>2</th>
        <th style={{ border: "1px solid #ddd", padding: "5px" }}>3</th>
        <th style={{ border: "1px solid #ddd", padding: "5px" }}>4</th>
        <th style={{ border: "1px solid #ddd", padding: "5px" }}>5</th>
        <th style={{ border: "1px solid #ddd", padding: "5px" }}>6</th>
        <th style={{ border: "1px solid #ddd", padding: "5px" }}>7</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td
          style={{
            border: "1px solid #ddd",
            padding: "5px",
            backgroundColor: "#f9f9f9",
            width: "200px",
          }}
        >
        $l^2+16$
        </td>
        <td style={{ border: "1px solid #ddd", padding: "5px" }}>16</td>
        <td style={{ border: "1px solid #ddd", padding: "5px" }}>17</td>
        <td style={{ border: "1px solid #ddd", padding: "5px" }}>20</td>
        <td style={{ border: "1px solid #ddd", padding: "5px" }}>25</td>
        <td style={{ border: "1px solid #ddd", padding: "5px" }}>32</td>
        <td style={{ border: "1px solid #ddd", padding: "5px" }}>41</td>
        <td style={{ border: "1px solid #ddd", padding: "5px" }}>52</td>
        <td style={{ border: "1px solid #ddd", padding: "5px" }}>65</td>
      </tr>
      <tr>
        <td
          style={{
            border: "1px solid #ddd",
            padding: "5px",
            backgroundColor: "#f9f9f9",
            width: "200px",
          }}
        >
        $l^2+16$가 완전제곱수?
        </td>
        <td style={{ border: "1px solid #ddd", padding: "5px" }}>O</td>
        <td style={{ border: "1px solid #ddd", padding: "5px" }}>X</td>
        <td style={{ border: "1px solid #ddd", padding: "5px" }}>X</td>
        <td style={{ border: "1px solid #ddd", padding: "5px" }}>O</td>
        <td style={{ border: "1px solid #ddd", padding: "5px" }}>X</td>
        <td style={{ border: "1px solid #ddd", padding: "5px" }}>X</td>
        <td style={{ border: "1px solid #ddd", padding: "5px" }}>X</td>
        <td style={{ border: "1px solid #ddd", padding: "5px" }}>X</td>
      </tr>
    </tbody>
  </table>

- $k=4,5$이므로 $\frac{a}{b}=\frac12,1,2$이다.[^1]
- 이제 각 경우에 대해 개수를 세면 된다.
  1. $a=b$인 경우 순서쌍 $(a,b)$의 개수는 $N$개이다.
  1. $a<b$인 경우 순서쌍 $(a,b)$의 개수는 $\left\lfloor\frac{N}{2}\right\rfloor$개이다.
  1. $a>b$인 경우는 2와 같다.
- 따라서 각 케이스에 대해 $\left\lfloor\frac{N}{2}\right\rfloor\times 2 + N = 2N - N\%2$를 출력해주면 된다.

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  int t; cin >> t;
  while (t--) {
    ll n; cin >> n;
    cout << (n*2 - n%2) << '\n';
  }

  return 0;
}
```

[^1]: 생각해보니 $(k-l)(k+l)=16$으로 인수분해 하고 정수해의 후보를 추리는 것이 더 깔끔해보인다.
