---
title: 2025년 2월 3주차 TIL
---

# TOC

# 250216

## BOJ 1105 : 팔 (Silver 1)

- 처음에는 나이브하게 $L$부터 $R$까지 돌 생각을 했지만 범위가 너무 넓어서 이건 아니겠다는 생각을 함.
- 이후에는 예시를 보고 $L$과 $R$의 자리수가 같을 때 leading 8의 최솟값인가 생각을 함.
- 그러다 $L=880808$, $R=880809$의 반례를 떠올리고 이것이 아님을 깨달음.
- 직관적으로 $L$과 $R$의 common prefix에서의 8의 개수라고 추측을 함.
- common prefix가 아닌 부분을 8이 아니도록 바꿈으로써 8의 개수를 최소화할 수 있을 것이라고 간단하게 논증을 세우고 코드를 짬.

```py
l, r = input().split()

if len(l) < len(r):
    print(0)
else:
    eight = 0
    for i in range(len(l)):
        if l[i] != r[i]:
            break
        if l[i] == '8':
            eight += 1
    print(eight)
```

## BOJ 1141 : 접두사 (Silver 1)

- $N$이 50이하로 작길래 조금 너그럽게 생각해도 되겠다고 생각했다.
- 첫번째 접근
  - 처음에 $\texttt{cnt}=N$으로 시작해서 $A \leq_P B$일 때, $\texttt{cnt}$를 하나씩 깎는 것으로 결과를 계산할 수 있을 것으로 예상했다.
  - 하지만 $\{\texttt{h},\texttt{hi},\texttt{hello}\}$에서 최적해가 2이므로 $A \leq_P B$에서 깎았으면 $B$가 아닌 문자열에 대해서는 더 이상 세지 않으면 될 것 같았다.
  - 예제 중 같은 단어가 두 번 등장할 때 문제가 발생하길래 pairwise하게 중복해서 세어지는 것을 제거했다.

  ```py
  n = int(input())
  s = []
  for i in range(n):
      s.append(input())

  cnt = n
  same = 0
  for i in range(n):
      for j in range(n):
          if i == j:
              continue
          if s[j].startswith(s[i]):
              cnt -= 1
              if s[i] == s[j]:
                  same += 1
              break

  cnt += same // 2
  print(cnt)
  ```

- 그러나 이는 올바른 방식이 아니었다. 결국 여기서 내재하는 구조는 $<_P$[^1]로 이어지는 트리 구조인데 이 트리의 leaf의 개수를 세는 것이 문제의 답인 것이다. leaf의 개수는 첫번째 접근에서처럼 전체 노드 수에서 하나씩 빼서는 구하기 어렵다.
- 두번째 접근
  - 위에서 말한 대로 짜면 된다. 동일한 단어는 최대 1개만 들어갈 수 있으므로 처음부터 중복 제거를 해준다. $O\left(N^2\right)$으로 해결할 수 있다.

  ```py
  n = int(input())
  s = []
  for i in range(n):
      s.append(input())

  s = list(set(s))
  n = len(s)

  l = [True] * n

  for i in range(n):
      for j in range(n):
          if i == j:
              continue
          if s[j].startswith(s[i]):
              l[i] = False

  print(sum(l))
  ```

## BOJ 6549 : 히스토그램에서 가장 큰 직사각형 (Platinum 5)

- 정말 많이, 그리고 오랫동안 (진짜 몇달간) 고민했던 문제다.
- 아무리 생각해도 $O\left(n^2\right)$ 방법 밖에 떠오르지 않아서 발상의 전환이 필요했다.
- $h_i$의 범위가 너무 커서 $h$를 기준으로 짜르면 안되지 않나 하고 일찌감치 버려두었다. 하지만, 오늘 좌표 압축 하면 되지 않을까 싶었다.
- $h_n$를 높이가 큰 순으로 정렬하고 각 $h_i$과 인접하는 것을 찾아서 Union-Find의 merge 연산을 해주면 된다고 생각했다.
- 원래는 높이를 `map<int,vector<int>>` 식으로 저장하는 게 낫지 않을까 싶었는데, 구현도 불편하고 그냥 해도 풀릴 것 같았다.
- 아무튼 풀고 나서 기분이 매우 좋았다.

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef vector<int> vi;
typedef long long ll;
typedef pair<int, int> pii;

struct UnionFind {
  vi parent;
  vi setSize;

  UnionFind(int n) {
    parent.resize(n, -1);
    setSize.resize(n, 0);
  }

  int getParent(int x) {
    if (parent[x] == -1) return -1;
    if (parent[x] == x) return x;
    return parent[x] = getParent(parent[x]);
  }

  // returns set size
  int merge(int a, int b) {
    a = getParent(a);
    b = getParent(b);
    if (a == -1 || b == -1) return 0;
    if (a < b)
      return parent[b] = a, setSize[a] += setSize[b]; // store size only in parent.
    return parent[a] = b, setSize[b] += setSize[a];
  }

  void addItem(int a) {
    parent[a] = a;
    setSize[a] = 1;
  }
};

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  int n;
  while (cin >> n, n > 0) {
    vector<pii> hp(n);
    UnionFind uf(n);
    for (int i=0;i<n;i++) {
      int h;
      cin >> h;
      hp.emplace_back(h, i);
    }
    sort(hp.begin(), hp.end(), greater());

    ll mm = hp[0].first;
    for (auto [h, p] : hp) {
      uf.addItem(p);

      if (p + 1 < n)
        mm = max(mm, (ll) uf.merge(p, p + 1) * h);
      if (p - 1 >= 0)
        mm = max(mm, (ll) uf.merge(p, p - 1) * h);
    }

    cout << mm << '\n';
  }

  return 0;
}
```

## BOJ 1011 : Fly me to the Alpha Centauri (Gold 5)

- 메모리를 512MB나 주길래 DP인가 싶었다.
- 근데 아무리 생각해봐도 DP로 할 수 있는게 없었다. 메모이제이션으로 하려고 했는데, 메모리 초과가 났다.
- 나열하다보니까 규칙이 보였다. `1 2 1`, `1 2 2 1`, `1 2 3 2 1` 이런 식으로 길이 내에서 최대 합을 이루는 수열을 생각하고, 그 합보다 작거나 같은 최장 수열의 길이를 결과로 내놓으면 된다.
- 앞으로는 큰 메모리나 긴 실행 시간으로부터 힌트를 얻으려고 하지 말아야겠다.

```py
n = int(input())
for i in range(n):
    a, b = map(int, input().split())
    x = b - a
    y = 0
    i = 1
    while True:
        y += (i + 1) // 2
        if y >= x:
            break
        i += 1

    print(i)
```

# 250217

## BOJ 1189 : 컴백홈 (Silver 1)

- $R$, $C$가 매우 작아서 백트래킹하면 되겠다고 생각했다.
- 처음에 `visited[r-1][0]`를 `true`로 초기화해주는 것을 까먹었다.

```cpp
#include <bits/stdc++.h>
using namespace std;

int r, c, k;
bool visited[5][5];
char _map[5][6];

const int D[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

int dfs(int i, int j, int cnt) {
  if (i == 0 && j == c-1)
    return cnt == k;

  int result = 0;
  for (auto [di, dj] : D) {
    if (i+di >= 0 && i+di < r && j+dj >= 0 && j+dj < c && _map[i+di][j+dj] == '.' && !visited[i+di][j+dj]) {
      visited[i+di][j+dj] = true;
      result += dfs(i+di, j+dj, cnt+1);
      visited[i+di][j+dj] = false;
    }
  }
  return result;
}

int main() {
  scanf("%d%d%d", &r, &c, &k);
  for (int i = 0; i < r; i++)
    scanf("%s", _map[i]);

  memset(visited, false, 25 * sizeof(bool));
  visited[r-1][0] = true;

  printf("%d", dfs(r - 1, 0, 1));
  return 0;
}
```

## BOJ 2607 : 비슷한 단어 (Silver 2)

- 단어의 조성을 파악하고 각 조성의 차이가 1 이하이되, 1과 -1이 각각 최대 1번까지만 등장 가능하다는 것을 고려하여 구현하면 된다.
- 단어의 개수를 $N$, 단어의 최대 길이를 $M$이라 할 때, 시간 복잡도는 $O(NM)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  int n; cin >> n;

  string s; cin >> s;

  int counter[28] = {0, };
  for (char ch : s)
    counter[ch-'A']++;

  int cnt = 0;
  for (int i=0;i<n-1;i++) {
    string s2; cin >> s2;

    int counter2[28] = {0, };
    for (char ch : s2)
      counter2[ch-'A']++;

    int minusOne = 0;
    int plusOne = 0;
    bool success = true;
    for (int j=0;j<28;j++) {
      int diff = counter[j] - counter2[j];
      if (diff < -1 || diff > 1) {
        success = false;
        break;
      }
      if (diff == -1) minusOne++;
      if (diff == 1) plusOne++;
    }
    if (success && minusOne <= 1 && plusOne <= 1) {
      cnt++;
    }
  }

  cout << cnt;

  return 0;
}
```

# 250218

## BOJ 1992 : 쿼드트리 (Silver 1)

- DFS로 쉽게 해결 가능하다.

```cpp
#include <bits/stdc++.h>
using namespace std;

string _map[64];

string dfs(int i, int j, int w) {
  if (w == 1) {
    return string(1, _map[i][j]);
  }

  string s1 = dfs(i, j, w/2);
  string s2 = dfs(i, j + w/2, w/2);
  string s3 = dfs(i + w/2, j, w/2);
  string s4 = dfs(i + w/2, j + w/2, w/2);

  if (s1[0] != '(' && s1[0] == s2[0] && s2[0] == s3[0] && s3[0] == s4[0]) {
    return s1;
  }
  return "(" + s1 + s2 + s3 + s4 + ")";
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  int n;
  cin >> n;

  for (int i=0;i<n;i++)
    cin >> _map[i];

  cout << dfs(0, 0, n);

  return 0;
}
```

## BOJ 7562 : 나이트의 이동 (Silver 1)

- BFS로 쉽게 해결 가능하다.

```cpp
#include <bits/stdc++.h>
using namespace std;

const int D[8][2] = {{1, 2}, {2, 1}, {1, -2}, {2, -1}, {-1, -2}, {-2, -1}, {-1, 2}, {-2, 1}};

struct Node {
  int i;
  int j;
  int c;
};

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  int t; cin >> t;

  while (t--) {
    int l; cin >> l;
    bool visited[l][l];
    memset(visited, false, l * l * sizeof(bool));
    int sx, sy; cin >> sx >> sy;
    int tx, ty; cin >> tx >> ty;

    queue<Node> q;
    q.push(Node { sx, sy, 0 });
    visited[sx][sy] = true;

    while (!q.empty()) {
      auto [i, j, c] = q.front();
      q.pop();

      if (i == tx && j == ty) {
        cout << c << '\n';
        break;
      }

      for (auto [di, dj] : D) {
        if (i+di>=0 && i+di<l && j+dj>=0 && j+dj<l && !visited[i+di][j+dj]) {
          visited[i+di][j+dj] = true;
          q.push(Node { i+di, j+dj, c+1 });
        }
      }
    }
  }

  return 0;
}
```

## BOJ 1850 : 최대공약수 (Silver 1)

- 푸는데 좀 시간이 걸렸다.
- 1로만 구성된 두 블록이 있다고 할 때, 작은 블록을 등분한 조각을 작은 블록에 이어붙여 큰 블록을 만들 수 있을까를 고민하여 접근하였다.
- 접근한 대로 맞긴 했지만 증명하는 게 어려워서 포기했다.
- GPT가 알려준 증명을 첨부하겠다.

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  ll a, b; cin >> a >> b;

  for (ll i=0;i<gcd(a, b);i++)
    cout << '1';

  return 0;
}
```

<Theorem title="증명">
    먼저, $a$, $b$를 양의 정수라고 하고, $d=\gcd(a,b)$라고 하자. 우리가 증명할 식은

    $$
    \gcd\left(\frac{10^a-1}{9},\frac{10^b-1}{9}\right)=\frac{10^d-1}{9}
    $$

    인데, 우선 분자에 대해 아래의 사실을 증명하자.

    $$
    \gcd(10^a-1,10^b-1)=10^d-1.
    $$

    ---

    1. __$10^d-1$이 $10^a-1$과 $10^b-1$의 공약수임을 보임__

      $d=\gcd(a,b)$이므로, 정수 $k,l$이 존재하여
      $$
      a = d \cdot k,\quad b = d \cdot l
      $$
      라고 할 수 있다.

      이때,
      $$
      10^a - 1 = 10^{dk} - 1 = \left(10^d-1\right)\left(10^{d(k-1)}+10^{d(k-2)}+\cdots+1\right)
      $$
      이므로, $10^d-1$은 $10^a-1$의 인수이다. 같은 논리로 $10^d-1$은 $10^b-1$의 인수이다.

      따라서, $10^d-1 \mid 10^a-1$이고 $10^d-1 \mid 10^b-1$이다.

    2. __$10^d-1$이 최대공약수임을 보임__

      반대로, $m$이 $10^a-1$과 $10^b-1$의 임의의 공약수라고 하자. 그러면
      $$
      10^a \equiv 1 \pmod{m}, \quad 10^b \equiv 1 \pmod{m}
      $$
      이다.

      Bézout의 정리에 의해, $d = \gcd(a,b)$는 $a$와 $b$의 정수 선형 결합으로 나타낼 수 있으므로, 즉 $s,t$가 존재하여
      $$
      d = s\cdot a + t\cdot b,
      $$
      양변에 $10$의 거듭제곱을 취하면
      $$
      10^d = 10^{s a + t b} = (10^a)^s \cdot (10^b)^t \equiv 1^s \cdot 1^t = 1 \pmod{m}.
      $$
      따라서,
      $$
      10^d \equiv 1 \pmod{m} \quad\Rightarrow\quad m \mid (10^d-1).
      $$

      즉, $10^d-1$은 $10^a-1$과 $10^b-1$의 모든 공약수를 나누므로,
      $$
      \gcd(10^a-1,10^b-1)=10^d-1.
      $$

    3. __최종 결론__

      문제에서 주어진 두 수는 $\frac{10^a-1}{9}$와 $\frac{10^b-1}{9}$이다. $10^a-1$과 $10^b-1$는 모두 $9$의 배수이므로, 양변을 $9$로 나누어도 최대공약수의 관계는 보존된다. 즉,
      $$
      \gcd\left(\frac{10^a-1}{9},\frac{10^b-1}{9}\right)
      =\frac{\gcd(10^a-1,10^b-1)}{9}
      =\frac{10^d-1}{9}.
      $$

      이로써
      $$
      \gcd\left(\frac{10^a-1}{9},\frac{10^b-1}{9}\right)=\frac{10^{\gcd(a,b)}-1}{9}
      $$
      임을 증명하였다. $\blacksquare$
</Theorem>

## BOJ 11403 : 경로 찾기 (Silver 1)

- Transitive Closure 구하는 문제이다.
- 처음에 반복문 순서를 헷갈렸는데, DP적 관점으로 생각할 때 $i\rightarrow j$로 갈 수 있는 다리가 $\left\{0,1,\cdots,k\right\}$ 중에 있는지를 점진적으로 확인해야 하기에 중간 다리인 $k$를 맨 나중에 놓는 것이다.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  int n; cin >> n;

  bool mat[100][100];
  for (int i=0;i<n;i++)
    for (int j=0;j<n;j++)
      cin >> mat[i][j];

  for (int k=0;k<n;k++)
    for (int i=0;i<n;i++)
      for (int j=0;j<n;j++)
        mat[i][j] = mat[i][j] || (mat[i][k] && mat[k][j]);

  for (int i=0;i<n;i++) {
    for (int j=0;j<n;j++) {
      cout << mat[i][j] << ' ';
    }
    cout << '\n';
  }

  return 0;
}
```

## BOJ 2583 : 영역 구하기 (Silver 1)

- DFS로 풀면 된다.
- 좌표가 제법 헷갈린다.

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

bool visited[100][100] = {false, };
bool mat[100][100] = {false, };

const int D[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
int m, n;

int dfs(int x, int y) {
  visited[y][x] = true;
  int result = 1;
  for (auto [dx, dy] : D) {
    if (x+dx>=0 && x+dx<n && y+dy>=0 && y+dy<m && !visited[y+dy][x+dx] && !mat[y+dy][x+dx]) {
      result += dfs(x+dx, y+dy);
    }
  }
  return result;
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  int k;
  cin >> m >> n >> k;
  for (int t=0;t<k;t++) {
    int x1, y1, x2, y2;
    cin >> x1 >> y1 >> x2 >> y2;
    for (int x=x1;x<x2;x++)
      for (int y=y1;y<y2;y++)
        mat[y][x] = true;
  }

  vector<int> results;
  for (int x=0;x<n;x++) {
    for (int y=0;y<m;y++) {
      if (!mat[y][x] && !visited[y][x]) {
        results.push_back(dfs(x, y));
      }
    }
  }

  sort(results.begin(), results.end());

  cout << results.size() << '\n';
  for (int result : results) {
    cout << result << ' ';
  }

  return 0;
}
```

## BOJ 11057 : 오르막 수 (Silver 1)

- 각 자릿수를 $x_i$ ($1\leq x\leq n$)이라 할 때, 다음을 만족하는 수의 개수를 찾는 문제이다.

  $$
  0 \leq x_1 \leq x_2 \leq x_3 \leq \cdots \leq x_n \leq 9
  $$

- 각 자릿수의 조성(0이 몇 개고, 1이 몇 개고, ...)만 결정하면 오르막수가 이것을 정렬한 것으로 유일하게 결정되므로 조성의 경우의 수를 찾으면 된다. 길이가 $n$인 수에서 숫자 $i$의 개수를 $c_i$ ($0\leq i\leq 9$)라고 할 때, 다음의 경우의 수를 세면 된다.

  $$
  c_0 + c_1 + c_2 + c_3 + ... + c_9 = n
  $$

- 중복조합으로 계산하면 $\left(\!\!{\binom {10}{n}}\!\!\right)=\binom{n+9}{n}=\binom{n+9}{9}$이다.
- 중복조합을 그냥 재귀로 계산하면 $O(2^n)$이므로 상당히 문제가 있다. 2D 메모이제이션을 활용하도록 하자. $O(n)$으로 해결 가능하다.

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MOD = 10007;

int memo[1010][1010] = {0, };

int comb(int n, int r) {
  if (n == r || r == 0) return 1;
  if (memo[n][r] > 0) return memo[n][r];
  return memo[n][r] = comb(n-1,r-1) % MOD + comb(n-1,r) % MOD;
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  int n; cin >> n;
  cout << (comb(n+9, 9) % MOD);

  return 0;
}
```

## BOJ 2688 : 줄어들지 않아 (Silver 1)

- 바로 윗 문제랑 비슷하다고 해서 날먹했다. 이러면 안 되려나...

## BOJ 1926 : 그림 (Silver 1)

- 또 DFS 문제다. 2583이랑 매우 비슷하다. 날먹 죄송

[^1]: 그러니까 동일한 단어는 고려하지 않는다는 말이다.
