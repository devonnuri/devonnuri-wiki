---
title: 2025년 12월 1주차 TIL
---

# TOC

# 251202

## BOJ 2342 : Dance Dance Revolution (Gold 3)

- DP 문제인데 애먹어서 못 풀다가 이제 풀었다.
- $dp_i[l][r]$을 $i$번째 위치를 밟을 때, 그리고 마지막 두 발의 위치가 $(l,r)$일 때의 최소의 총 힘이라고 정의하자. 그러면 다음과 같은 transition rule을 생각할 수 있다.

    $$
    \begin{align*}
    dp_i[x][r]
    &=
    \min \Bigl\{
    dp_{i-1}[l][r] + \operatorname{cost}(l, x)
    \;\Big|\;
    (l, r) \in S,\; r \neq x
    \Bigr\} \\
    dp_i[l][x]
    &=
    \min \Bigl\{
    dp_{i-1}[l][r] + \operatorname{cost}(r, x)
    \;\Big|\;
    (l, r) \in S,\; l \neq x
    \Bigr\}
    \end{align*}
    $$

    - 여기서 $S$는 허용 상태 집합이며 다음과 같이 정의된다.

        $$
        S = \{(l, r) \mid l, r \in \{0,1,2,3,4\},\; (l = r \Rightarrow l = 0)\}
        $$

- 각 $dp_i$ 상태는 직전 $dp_{i-1}$에만 영향을 받으므로 모두 저장할 필요 없다.

```py
from math import inf

l = [int(x) for x in input().split()][:-1]
dp = [[inf] * 5 for i in range(5)]
dp[0][0] = 0

def cost(x, y):
  if x == 0:
    return 2
  if x == y:
    return 1
  return 3 + ((x-y)%2 == 0)

for x in l:
  tmp = [[inf] * 5 for i in range(5)]
  for j in range(5):
    for k in range(5):
      if j == k and j != 0:
        continue
      tmp[x][j] = min(tmp[x][j], dp[k][j] + cost(k, x))
      tmp[j][x] = min(tmp[j][x], dp[j][k] + cost(k, x))
  dp=tmp

print(min([min(x) for x in dp]))
```

## BOJ 2170 : 선 긋기 (Gold 5)

- 스위핑 기초다. 이벤트 리스트가 포인트이다.

```cpp
#include <bits/stdc++.h>

using namespace std;

using vi = vector<int>;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  vector<pi> events;
  int n; cin >> n;

  for (int i=0;i<n;i++) {
    int l, r; cin >> l >> r;
    events.emplace_back(l, 1);
    events.emplace_back(r, -1);
  }

  sort(events.begin(), events.end());

  int cur = 0, start = 0, res = 0;
  for (auto [p, e] : events) {
    if (e == 1 && cur == 0) start = p;
    cur += e;
    if (e == -1 && cur == 0) res += p - start;
  }
  cout << res;

  return 0;
}
```

## BOJ 20412 : 추첨상 사수 대작전! (Hard) (Gold 2)

$$
\begin{align*}
(a\times S + c) \equiv X_1 \pmod{m} \\
(a\times X_1 + c) \equiv X_2 \pmod{m}
\end{align*}
$$

이 두 식을 빼면,

$$
a\times(S - X_1) \equiv X_1 - X_2 \pmod{m}
$$

1. $S = X_1$일때,

    $X_1 = X_2$이므로, 해 $(a,c)$는 무수히 많다. $(1, 0)$으로 잡을 수 있다.

2. $S \neq X_1$일때,

    페르마의 소정리에 의해,

    $$
    \begin{align*}
    a &\equiv (X_1 - X_2)\times(S - X_1)^{-1} \pmod{m} \\
      &\equiv (X_1 - X_2)\times(S - X_1)^{m-2} \pmod{m}
    \end{align*}
    $$

    $c$는 첫 식에 대입해서 구하면 된다.

```py
m, s, x1, x2 = map(int, input().split())
if s==x1:
  print(1, 0)
else:
  a = (x1-x2)*pow((s-x1)%m,-1,m)%m
  c = (x1-a*s)%m
  print(a,c)
```

# 241204

## BOJ 13975 : 파일 합치기 3 (Gold 4)

- 허프만 코딩 문제다.

- 허프만 코딩 증명은 다음과 같이 하면 된다. 이거 하면서 교환 논법 감 잡은듯.

    - 다음을 증명한다.

        > 주어진 가중치 $w_1$, $\cdots$, $w_n$에 대해
        > 항상 가장 작은 두 개를 합쳐 가중치 $w_i+w_j$인 새 노드를 만들고,
        > 이걸 반복해서 만든 이진트리가 전체 가중 경로 길이 $\sum w_i\cdot \text{depth}(i)$를 최소로 한다.
    
    - 이를 위해 다음 두 Lemma를 증명한다.
        1. 가장 작은 두 가중치는 최적 트리에서 형제(같은 부모)로 둘 수 있다.
            - 얘는 교환 논법으로 증명할 수 있는데, 최적 트리의 가장 깊은 리프가 가중치가 가장 작지 않을 경우, 그렇게 바꾼 뒤 비용 변화가 얼마가 될지 구하면 된다.
        2. 두 최소 가중치를 하나로 합치면 부분문제도 최적이다.
            - 이 부분은 직관적으로 알 수 있다.
    
    - Lemma를 모두 증명한 뒤엔 수학적 귀납법으로 마무리하면 된다.

```py
from heapq import heapify, heappop, heappush

t=int(input())
for _ in range(t):
  n=int(input())
  q=[int(x) for x in input().split()]
  heapify(q)
  res=0
  while len(q)>1:
    a,b=heappop(q),heappop(q)
    heappush(q, a+b)
    res+=a+b
  print(res)
```

# 251205

## BOJ 11401 : 이항 계수 3 (Gold 1)

- 단계별로 풀어보기에서 힌트를 줘서 풀었다.

- 이항계수를 구하면 다음과 같다. 역원은 페르마의 소정리로 구하면 된다.

    $$
    \begin{align*}
    \binom{n}{k} &\equiv \left(\prod_{i=n-k+1}^{n} i\right) \cdot (k!)^{-1} \pmod{p} \\
                 &\equiv \left(\prod_{i=n-k+1}^{n} i\right) \cdot (k!)^{p-2} \pmod{p}
    \end{align*}
    $$

```py
n,k=map(int,input().split())
res=1
p=int(1e9)+7
for i in range(n-k+1,n+1):
  res=(res*i)%p
k_fac=1
for i in range(1,k+1):
  k_fac=(k_fac*i)%p
res=(res*pow(k_fac,p-2,p))%p
print(res)
```

## BOJ 1069 : 집으로 (Gold 3)

- Exhaustive하게 케이스 분류를 하자면, $d>l$ ($l=\sqrt{x^2+y^2}$)일 때, $d\leq l$일 때를 나누고, 그 안에서 0번 점프, 1번 점프, ...를 나누어서 최소 시간 케이스를 고르면 된다.
- $d>l$일 때에는 0번 점프, 1번 점프, 2번 점프 중 하나가 최적이고, 그 이상 점프하면 2번 점프보다 항상 비효율적이다.
- $d\leq l$일 때에는 0번 점프, $n$번 점프, $n+1$ 점프 중 하나가 최적이다. ($n=\left\lfloor l/d \right\rfloor$)

```py
x,y,d,t=map(int,input().split())
l=(x*x+y*y)**.5
if d>l:
  print(min(t+d-l,l,2*t))
else:
  n=int(l/d)
  print(min(n*t+l-n*d,(n+1)*t,l))
```